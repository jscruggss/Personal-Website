<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-12-08">

<title>Classification of Winners in NBA Games</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-b6254045a21d07dd46cfe160e8c2e3db.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../courses.html"> 
<span class="menu-text">Courses</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">1. Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">2. Introduction</a>
  <ul class="collapse">
  <li><a href="#our-problem" id="toc-our-problem" class="nav-link" data-scroll-target="#our-problem">Our Problem</a></li>
  <li><a href="#variables-of-the-study" id="toc-variables-of-the-study" class="nav-link" data-scroll-target="#variables-of-the-study">Variables of the Study</a></li>
  </ul></li>
  <li><a href="#exploratory-analysis" id="toc-exploratory-analysis" class="nav-link" data-scroll-target="#exploratory-analysis">3. Exploratory Analysis</a></li>
  <li><a href="#analysis" id="toc-analysis" class="nav-link" data-scroll-target="#analysis">4. Analysis</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">5. Results</a>
  <ul class="collapse">
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#interpretation" id="toc-interpretation" class="nav-link" data-scroll-target="#interpretation">Interpretation</a></li>
  </ul></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">6. Conclusions</a>
  <ul class="collapse">
  <li><a href="#challenges-of-the-study" id="toc-challenges-of-the-study" class="nav-link" data-scroll-target="#challenges-of-the-study">Challenges of the Study</a></li>
  <li><a href="#recommendations-for-the-future" id="toc-recommendations-for-the-future" class="nav-link" data-scroll-target="#recommendations-for-the-future">Recommendations for the Future</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Classification of Winners in NBA Games</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jacob Kelman, Jason Scruggs, Bowen Zheng </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 8, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">1. Abstract</h2>
<p>This study aims to develop a predictive model for forecasting the outcomes of NBA games using historical game data, in this case, data from the 2023-24 Season. We divided our data into an 80/20 train test split. However, rather than randomizing the split, we split the data based on time, training the data using matchups from the first 80% of the season, and testing it on data from the remaining 20% of matchups. Of the models tested, Logistic Regression with an L1 regularization penalty demonstrated the most effectiveness producing a game prediction accuracy of over 70%. This model outperforms an unpenalized Logistic Regression, as well as Random Forest, Gradient Boosting, and Ridge Regression. Using the given NBA statistics as well as the features we engineered from the original statistics, it was found that the most influential predictors were the difference in weighted average win percentage between the two opposing teams, whether the team was playing at home, the average points scored by both opposing teams, the difference in points conceded by each team, the difference in variance of points scored by each team, and the difference in average FG% of each team. The results suggest that teams with better historical records (particularly records with many recent wins), stable scoring patterns, good scoring ability, and strong defenses are likely to win.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">2. Introduction</h2>
<section id="our-problem" class="level3">
<h3 class="anchored" data-anchor-id="our-problem">Our Problem</h3>
<p>In competitive sports, both fans and teams care about the performance of their respective teams. With the recent legalization and popularization of American sports betting, the outcome of a game could mean the gain or loss of millions of dollars, not to mention the impact of each game to their respective sports. The goal of this study is to build a model to predict whether a team will win a game based on historical data from not only the individual team but the entirety of the NBA.</p>
</section>
<section id="variables-of-the-study" class="level3">
<h3 class="anchored" data-anchor-id="variables-of-the-study">Variables of the Study</h3>
<p>Given these variables, the study seeks to explore their interrelationships and assess their potential impact on game outcomes. The relationships identified during this exploratory analysis will inform the subsequent analysis and development of more sophisticated features.</p>
<table class="table-striped caption-top table">
<caption>Variables</caption>
<thead>
<tr class="header">
<th>Variables</th>
<th>Categorical vs Numerical</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Team</td>
<td>Categorical</td>
<td>Team Name</td>
</tr>
<tr class="even">
<td>Match Up</td>
<td>Categorical</td>
<td>Description of the meeting teams</td>
</tr>
<tr class="odd">
<td>Game Date</td>
<td>Categorical</td>
<td>Date of the game (MM/DD/YYYY)</td>
</tr>
<tr class="even">
<td>W/L</td>
<td>Categorical</td>
<td>Win or Loss</td>
</tr>
<tr class="odd">
<td>MIN</td>
<td>Numerical</td>
<td>Minutes Played</td>
</tr>
<tr class="even">
<td>PTS</td>
<td>Numerical</td>
<td>Points Scored</td>
</tr>
<tr class="odd">
<td>FGM</td>
<td>Numerical</td>
<td>Field Goals Made</td>
</tr>
<tr class="even">
<td>FGA</td>
<td>Numerical</td>
<td>Field Goals Attempted</td>
</tr>
<tr class="odd">
<td>FG%</td>
<td>Numerical</td>
<td>Field Goal Percentage</td>
</tr>
<tr class="even">
<td>3PM</td>
<td>Numerical</td>
<td>3-Point Shots Made</td>
</tr>
<tr class="odd">
<td>3PA</td>
<td>Numerical</td>
<td>3-Point Shots Attempted</td>
</tr>
<tr class="even">
<td>3P%</td>
<td>Numerical</td>
<td>3-Point Shot Percentage</td>
</tr>
<tr class="odd">
<td>FTM</td>
<td>Numerical</td>
<td>Free Throws Made</td>
</tr>
<tr class="even">
<td>FTA</td>
<td>Numerical</td>
<td>Free Throws Attempted</td>
</tr>
<tr class="odd">
<td>FT%</td>
<td>Numerical</td>
<td>Free Throw Percentage</td>
</tr>
<tr class="even">
<td>OREB</td>
<td>Numerical</td>
<td>Offensive Rebounds</td>
</tr>
<tr class="odd">
<td>DREB</td>
<td>Numerical</td>
<td>Defensive Rebounds</td>
</tr>
<tr class="even">
<td>REB</td>
<td>Numerical</td>
<td>Total Rebounds</td>
</tr>
<tr class="odd">
<td>AST</td>
<td>Numerical</td>
<td>Assists</td>
</tr>
<tr class="even">
<td>STL</td>
<td>Numerical</td>
<td>Steals</td>
</tr>
<tr class="odd">
<td>BLK</td>
<td>Numerical</td>
<td>Blocks</td>
</tr>
<tr class="even">
<td>TOV</td>
<td>Numerical</td>
<td>Turnovers</td>
</tr>
<tr class="odd">
<td>PF</td>
<td>Numerical</td>
<td>Personal Fouls</td>
</tr>
<tr class="even">
<td>+/-</td>
<td>Numerical</td>
<td>Point Differential</td>
</tr>
</tbody>
</table>
<p>The raw dataset was found to be generally well-structured, with nearly all columns containing complete data and no missing values. A single instance was identified where a team did not attempt any free throws in a game; in this case, an imputed value was assigned to ensure consistency with the analysis requirements. Given the overall completeness and quality of the data, minimal preprocessing and data wrangling were required.</p>
</section>
</section>
<section id="exploratory-analysis" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-analysis">3. Exploratory Analysis</h2>
<p>The initial step of exploratory analysis involved examining the already existing variables to identify those that are significant and could contribute to feature engineering. A preliminary look at a correlation heatmap confirms the expectation that points (PTS) and field goals made (FGM) would be strong predictors. Interestingly, field goal percentage (FG%), defensive rebounds (DREB), and assists (AST) also demonstrated notable correlation, suggesting their potential relevance.</p>
<p>Following our initial analysis, new variables were engineered to capture additional patterns within the data: home advantage, matchup win percentage, general win percentage, points variation, and points conceded. A correlation matrix was used to visualize these engineered variables, the differences between matches, and their relationships. Strong correlations once again indicate that these variables may serve as contributing predictors in the predictive models. This exploratory analysis provides a framework for our final variable selection with which the models will be tested.</p>
<p><img src="NBACorrelation.png" class="img-fluid"></p>
<p>With the evaluation of the correlation matrix, one of the variables that piqued interest was the ‘Last 5 Win Percent’ feature as this feature resulted in a correlation percentage of over 70% with both the ‘Last Five Win Percentage Difference’ and, most interestingly, the ‘General Win Percentage’.</p>
<p><img src="NBABoxPlot.png" class="img-fluid"></p>
<p>This trend suggests that a team’s latest five games are a strong indicator of the probability of winning their next match. Observing this, we decided to allocate more weight to the results of a team’s most recent games compared to their earlier games. The weight is defined using an exponentially decreasing sequence, where the weight assigned to each game is calculated as:</p>
<p><span class="math display">\[
w_j = \frac{\alpha^{n-j}}{\sum_{k=1}^{n-1}\alpha^{n-k}}
\]</span></p>
<p>Here, <span class="math inline">\(w_j\)</span> represents the weight for game j, α = 0.2 is the decay factor, n is the total number of prior games, and j is the position of the game in the sequence, with j=1 corresponding to the earliest game and j=n the most recent. This approach ensures that recent games have a proportionally greater impact on the weighted win percentage while older games contribute less influence.</p>
<p>Based on an exploration of all the features of interest, a deeper consideration of the correlation between 3 specific features was conducted. The correlation between ‘Win Rate Difference’, ‘Avg +/-’, and ‘Last 5 Win Percent’ was found to be higher than random chance would suggest.</p>
<p>The figure above shows a visual representation of the correlation between the three features and with further analysis we can deduce a percentage of correlation between said three features.</p>
<p><img src="NBAExplore.png" class="img-fluid"></p>
<p>The correlation between ‘Win Rate Difference’ and ‘Avg +/-’ suggests a team with a better win rate is typically more dominant in their games. This indicates higher offensive skill is more indicative of a team’s likelihood of winning. For this reason, we gave more importance to the points scored rather than any of the rebounds, blocks, or overall defensive metrics.</p>
</section>
<section id="analysis" class="level2">
<h2 class="anchored" data-anchor-id="analysis">4. Analysis</h2>
<p>To develop a predictive model for NBA game outcomes, a new set of features was engineered and used to create a comprehensive dataset for training and testing. The dataset was split into two parts: the first 80% of the season’s games were used for training the models, while the remaining 20% were reserved for testing. This separation ensured that the models were evaluated on data they had not seen during training, preserving the validity of the results.</p>
<p>Several machine learning models were tested, including Logistic Regression with no penalty, Logistic Regression with an L1 penalty, Ridge Regression, Random Forest, and Gradient Boosting. Among these, Logistic Regression with an L1 penalty demonstrated the highest predictive accuracy, establishing it as the best-performing model in our analysis.</p>
<p>The L1 penalty in our Logistic Regression applies a penalty to the coefficients of a linear model, which eliminates less relevant features by shrinking their coefficients. This approach enables the model to focus on the most informative predictors while reducing complexity, thus preventing overfitting</p>
<table class="table-striped caption-top table">
<caption>Final List of Predictive Features</caption>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Variables</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Home</td>
<td>Binary variable indicating if a given team is playing at home (1) or away (0)</td>
</tr>
<tr class="even">
<td>Diff Weighted GWP</td>
<td>Difference of weighted win percentage (as described previously) of the selected team and their opponent</td>
</tr>
<tr class="odd">
<td>AVG Points</td>
<td>Average number of points scored per game</td>
</tr>
<tr class="even">
<td>Opp Avg Points</td>
<td>Average number of points conceded per game</td>
</tr>
<tr class="odd">
<td>Diff Avg Points Conceded</td>
<td>Difference in average points conceded per game of the two given teams</td>
</tr>
<tr class="even">
<td>Diff PTS Var</td>
<td>Difference in the variance of each teams points scored per game</td>
</tr>
<tr class="odd">
<td>Diff of Avg Points Scored</td>
<td>Difference in the means of each teams points scored per game</td>
</tr>
</tbody>
</table>
<p>The final features used to train our model are described in the table above. These features were selected to capture critical aspects of team performance and competitiveness. The difference in weighted general win percent is our most significant feature. The Difference in Weighted General Win Percentage (Diff Weighted GWP) is important because it provides a nuanced measure of a team’s overall performance and momentum leading into a matchup. By weighting recent games more heavily, the Diff Weighted GWP accounts for a team’s current form. This is critical because teams often perform differently at various points in a season due to factors like injuries, strategy adjustments, or player fatigue. Diff Weighted GWP blends both a team’s season-long consistency and its short-term fluctuations. By looking at the difference in weighted win percentages between two teams, the metric highlights which team has been performing better in the context of recent games. This comparative analysis directly informs which team should be favored under “all things being equal” scenarios.</p>
<p>The Diff PTS Var measures the difference in the variance of points scored between teams, reflecting consistency. Teams with lower variance are more reliable and stable, while streakier teams with higher variance are less consistent and more likely to lose. This metric highlights a team’s stability, making it a strong predictor of outcomes. The rest of the features are general metrics of team performance on both the offensive and defensive end. When examined in relation to each other, they can suggest which team has a competitive advantage on both ends of the court.</p>
<p>It is a widely understood principle in sports that the home team has a competitive advantage. The dataset was constructed by aggregating historical data for each team, emphasizing recent performances through exponentially decreasing weights, and calculating performance differences between opposing teams. This structure ensured that the model prioritized recent trends, which are often more indicative of future outcomes.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">5. Results</h2>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>In this analysis, the performance of several different machine learning models to predict the outcome of each NBA game was evaluated. Among the models tested, Logistic Regression for classification was the most accurate, achieving an accuracy of 70.37%, this is due to the L1-penalty’s ability to penalize the less informative predictors and selecting only the most relevant features for the model. The next best model was Random Forest, with an accuracy of 67.8%. An unpenalized logistic model had an accuracy of 67.28%. Ridge Regression had a slightly lower accuracy of 67.08%, and Gradient Boosting exhibited the lowest predictive accuracy at 60.3%.</p>
<p>An analysis of feature importance revealed that the difference in weighted general win percentage between the two teams was the most predictive variable, showing a correlation of 0.324 with game outcomes. Within the Logistic Regression model, the L1 penalty allowed us to identify features that were labeled as influential. These influential features included the difference in win percentage, the variability of points scored per game, and the difference in average points conceded by each team. These findings highlight the significance of team consistency, scoring variability, and defensive strength in predicting game outcomes.</p>
</section>
<section id="interpretation" class="level3">
<h3 class="anchored" data-anchor-id="interpretation">Interpretation</h3>
<p>Teams with a stronger historical record of wins are statistically more likely to secure future victories, especially when competing against teams with lower win rates. Consistency in scoring further enhances a team’s probability of success, as it indicates reliability in offensive performance. Similarly, strong defensive capabilities, quantified by fewer points conceded, serve as a critical determinant of a team’s overall competitiveness.</p>
<p>To improve predictive accuracy, our model incorporates a weighted approach to these factors, assigning greater importance to recent games. This recency-weighted framework reflects the intuition that recent performance trends, such as momentum or short-term adjustments in strategy and form, are more predictive of near-term outcomes. By combining these weighted metrics with additional performance indicators, our model captures both the long-term stability and short-term dynamics of team performance, providing a robust and data-driven foundation for outcome prediction.</p>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">6. Conclusions</h2>
<section id="challenges-of-the-study" class="level3">
<h3 class="anchored" data-anchor-id="challenges-of-the-study">Challenges of the Study</h3>
<p>One of the most significant challenges in our project was identifying how to maximize the predictive power of our model using the available data. Translating what makes a basketball team “good” into meaningful numerical predictors was a complex process that required both domain knowledge and statistical reasoning. Generating features that captured relevant aspects of team performance was the first hurdle, followed by the task of determining which combination of features would yield the most accurate predictions.</p>
<p>Balancing model complexity with the risk of overfitting was another critical challenge. Overloading the model with weakly correlated or redundant features threatened to diminish its generalizability. To address this, we tested multiple models and feature sets to identify the optimal balance. Additionally, we experimented with limiting the influence of older games in the dataset, which reinforced our hypothesis that placing greater weight on recent games significantly improved the model’s ability to capture momentum and current team form.</p>
</section>
<section id="recommendations-for-the-future" class="level3">
<h3 class="anchored" data-anchor-id="recommendations-for-the-future">Recommendations for the Future</h3>
<p>Looking ahead, more attention should be given to fully exploring the potential of the original predictors before diving into feature engineering. While feature engineering was a critical part of our analysis, many of the derived features offered limited improvement over the raw data. A more systematic approach to evaluating engineered features could save time and resources in future projects.</p>
<p>We also recommend expanding the scope of hyperparameter optimization across models. Exploring a broader range of regularization parameters, penalty terms, and model-specific hyperparameters (e.g., tree depth for Random Forest) could uncover improvements in accuracy. Furthermore, incorporating advanced techniques like cross-validation or ensemble methods might enhance the robustness and predictive power of the model.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>© 2024, Jason Scruggs</p>
</div>
  </div>
</footer>




</body></html>